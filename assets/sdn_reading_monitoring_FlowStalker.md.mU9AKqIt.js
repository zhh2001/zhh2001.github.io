import{_ as t,c as a,o as e,ag as r}from"./chunks/framework.BZemHgQ6.js";const o="/reading/FlowStalker/CrawlerPacket.png",i="/reading/FlowStalker/throughput.png",n="/reading/FlowStalker/overhead.png",s="/reading/FlowStalker/latency.png",_=JSON.parse('{"title":"FlowStalker: Comprehensive Traffic Flow Monitoring on the Data Plane Using P4","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"sdn/reading/monitoring/FlowStalker.md","filePath":"sdn/reading/monitoring/FlowStalker.md"}'),h={name:"sdn/reading/monitoring/FlowStalker.md"};function d(c,l,p,u,w,g){return e(),a("div",null,l[0]||(l[0]=[r('<h1 id="flowstalker-comprehensive-traffic-flow-monitoring-on-the-data-plane-using-p4" tabindex="-1">FlowStalker: Comprehensive Traffic Flow Monitoring on the Data Plane Using P4 <a class="header-anchor" href="#flowstalker-comprehensive-traffic-flow-monitoring-on-the-data-plane-using-p4" aria-label="Permalink to &quot;FlowStalker: Comprehensive Traffic Flow Monitoring on the Data Plane Using P4&quot;">​</a></h1><blockquote><p>发表会议：2019 IEEE International Conference on Communications (ICC)<br> 发表时间：15 July 2019<br> 会议时间：20-24 May 2019<br> 会议地点：Shanghai, China<br> DOI：10.1109/ICC.2019.8761197</p></blockquote><p>FlowStalker 是一种基于 P4 的网络监控系统，通过<a href="#21-两阶段监控机制">两阶段监控</a>和<a href="#22-数据收集机制"> Cp 数据收集机制</a>，实现了高效、准确的网络流量监控。它减少了对控制平面的依赖，降低了通信开销，并为未来的网络监控方法提供了一个新的思路。</p><h2 id="_1-背景与动机" tabindex="-1">1 背景与动机 <a class="header-anchor" href="#_1-背景与动机" aria-label="Permalink to &quot;1 背景与动机&quot;">​</a></h2><h3 id="_1-1-传统网络监控的局限性" tabindex="-1">1.1 传统网络监控的局限性 <a class="header-anchor" href="#_1-1-传统网络监控的局限性" aria-label="Permalink to &quot;1.1 传统网络监控的局限性&quot;">​</a></h3><ul><li>传统交换机只暴露有限的转发平面信息，导致网络状态的获取依赖于低效的方法。</li><li>这些方法通常需要大量的计算资源，并且无法提供实时的网络状态信息。</li><li>例如，sFlow <a href="#sFlow">[4]</a> 和 NetFlow <a href="#NetFlow">[6]</a> 等传统监控方法通过采样或聚合流量信息来减少开销，但这种方法可能导致数据不准确。</li></ul><div class="tip custom-block"><p class="custom-block-title">文献引用</p><p><span id="sFlow">[4]</span> sFlow, &quot;sFlow - making the network visible,&quot; Available at: <a href="https://sflow.org/" target="_blank" rel="noreferrer">https://sflow.org/</a>, last accessed in Feb 17, 2019.</p><p><span id="NetFlow">[6]</span> Cisco, &quot;Introduction to Cisco IOS NetFlow - a technical overview,&quot; <a href="https://www.cisco.com/c/en/us/products/collateral/ios-nx-os-software/ios-netflow/prod_white_paper0900aecd80406232.html" target="_blank" rel="noreferrer">https://www.cisco.com/c/en/us/products/collateral/ios-nx-os-software/ios-netflow/prod_white_paper0900aecd80406232.html</a>, last accessed in Feb 17, 2019.</p></div><h3 id="_1-2-p4-语言的潜力" tabindex="-1">1.2 P4 语言的潜力 <a class="header-anchor" href="#_1-2-p4-语言的潜力" aria-label="Permalink to &quot;1.2 P4 语言的潜力&quot;">​</a></h3><ul><li>P4 是一种专门为数据平面编程设计的语言，允许直接在交换机上编程，从而实现更灵活的网络操作。</li><li>P4 的可编程性为重新设计网络监控方法提供了机会，可以在数据平面直接完成许多传统上由控制平面完成的任务（如流量监控和信息聚合）。</li></ul><h3 id="_1-3-flowstalker-的目标" tabindex="-1">1.3 FlowStalker 的目标 <a class="header-anchor" href="#_1-3-flowstalker-的目标" aria-label="Permalink to &quot;1.3 FlowStalker 的目标&quot;">​</a></h3><ul><li>提出一种基于 P4 的高效监控机制，能够在数据平面直接完成流量监控和信息聚合。</li><li>通过减少对控制平面的依赖，降低控制路径的通信开销，同时提高监控的准确性和效率。</li></ul><h2 id="_2-flowstalker-的设计" tabindex="-1">2 FlowStalker 的设计 <a class="header-anchor" href="#_2-flowstalker-的设计" aria-label="Permalink to &quot;2 FlowStalker 的设计&quot;">​</a></h2><h3 id="_2-1-两阶段监控机制" tabindex="-1">2.1 两阶段监控机制 <a class="header-anchor" href="#_2-1-两阶段监控机制" aria-label="Permalink to &quot;2.1 两阶段监控机制&quot;">​</a></h3><p>FlowStalker 的监控机制分为两个阶段：</p><ol><li><p><strong>主动阶段（Proactive Phase）</strong></p><ul><li><strong>功能:</strong> 过滤掉不相关的流量，只关注目标流量。</li><li><strong>实现:</strong><ul><li>每个进入交换机的流量都会被检查。</li><li>通过简单的计数器和低阈值来识别目标流量。</li><li>当流量的计数器超过低阈值时，该流量被标记为目标流量，进入反应阶段。</li></ul></li></ul></li><li><p><strong>反应阶段（Reactive Phase）</strong></p><ul><li><strong>功能:</strong> 对目标流量进行详细的监控和数据采集。</li><li><strong>实现:</strong><ul><li>在交换机中维护一个哈希表，用于存储目标流量的详细信息。</li><li>每个目标流量的每个数据包都会被监控并记录，包括： <ul><li><strong>每流数据:</strong> 如字节数、包数、RTT 的移动平均值等。</li><li><strong>每包数据:</strong> 如时间戳、包大小等。</li></ul></li><li>当流量的计数器超过高阈值时，触发警告并通知控制器。</li></ul></li></ul><p>下表展示了数据平面收集到的原始数据，以及可推导出来的数据：</p><table><caption><strong>DERIVATIONS OF RAW METRICS</strong></caption><thead><tr><th></th><th>原始数据</th><th>派生数据</th></tr></thead><tbody><tr><td rowspan="4"><strong>Per-Flow</strong></td><td>Byte Counts</td><td>Bytes/Second</td></tr><tr><td>Packet Drops</td><td rowspan="2">Flow Error Rate</td></tr><tr><td>Packet Counts</td></tr><tr><td>Flow Start</td><td>Flow Duration</td></tr><tr><td rowspan="3"><strong>Per-Packet</strong></td><td>Packet Size</td><td>Packet Length variance</td></tr><tr><td rowspan="2">Timestamps</td><td>Processing Latency</td></tr><tr><td>Inter-Packet Arrival Times</td></tr></tbody></table></li></ol><h3 id="_2-2-数据收集机制" tabindex="-1">2.2 数据收集机制 <a class="header-anchor" href="#_2-2-数据收集机制" aria-label="Permalink to &quot;2.2 数据收集机制&quot;">​</a></h3><p>FlowStalker 引入了一种称为 <strong>Crawler Packet (Cp)</strong> 的机制，用于高效地收集数据平面中的状态信息：</p><p align="center"><img width="95%" src="'+o+'"></p><ul><li><p><strong>Crawler Packet 的作用</strong>：</p><ul><li>当控制器收到警告后，会生成一个 Cp 并注入到目标集群中。</li><li>Cp 在集群内按照预定义的路径传播，每个交换机将状态信息附加到 Cp 中。</li><li>最终，Cp 返回控制器，携带所有交换机的状态信息。</li></ul></li><li><p><strong>优势:</strong></p><ul><li>避免了传统方法中控制器逐个轮询交换机的高开销。</li><li>减少了控制路径的通信量，提高了数据收集的效率。</li></ul></li></ul><h3 id="_2-3-网络分簇" tabindex="-1">2.3 网络分簇 <a class="header-anchor" href="#_2-3-网络分簇" aria-label="Permalink to &quot;2.3 网络分簇&quot;">​</a></h3><ul><li>为了进一步优化数据收集，网络被划分为多个逻辑组（集群）。</li><li>每个集群内的交换机通过 DFS 算法确定一条路径，用于 Cp 的传播。</li><li>这种分簇方法减少了控制器的通信负担，并避免了控制路径的瓶颈。</li></ul><h2 id="_3-实验评估" tabindex="-1">3 实验评估 <a class="header-anchor" href="#_3-实验评估" aria-label="Permalink to &quot;3 实验评估&quot;">​</a></h2><h3 id="_3-1-监控系统的性能" tabindex="-1">3.1 监控系统的性能 <a class="header-anchor" href="#_3-1-监控系统的性能" aria-label="Permalink to &quot;3.1 监控系统的性能&quot;">​</a></h3><ul><li><strong>实验设置:</strong> 在 BMv2 P4 软件交换机上运行 FlowStalker，使用 iPerf 测试 TCP 流的吞吐量。</li><li><strong>结果:</strong><ul><li>FlowStalker 的监控机制对吞吐量的影响较小（约 12% 的下降）。</li><li>增加监控的指标数量对吞吐量没有显著影响，表明 FlowStalker 的开销是固定的。</li></ul></li></ul><p align="center"><img width="70%" src="'+i+'"></p><h3 id="_3-2-数据收集系统的性能" tabindex="-1">3.2 数据收集系统的性能 <a class="header-anchor" href="#_3-2-数据收集系统的性能" aria-label="Permalink to &quot;3.2 数据收集系统的性能&quot;">​</a></h3><ul><li><p><strong>通信开销实验:</strong></p><ul><li>比较了 FlowStalker 和传统 OpenFlow 方法在不同数据负载下的通信开销。</li><li>结果表明，FlowStalker 的通信开销显著低于 OpenFlow 方法。</li></ul></li></ul><p align="center"><img width="80%" src="'+n+'"></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>上面实验对比的 OpenFlow 方法不是真的基于 OpenFlow 的方法，而是 BMv2 软件交换机的 P4Runtime Thrift API，作者认为和 OpenFlow 类似，所以这样叫。</p></div><ul><li><p><strong>延迟实验:</strong></p><ul><li>测试了 Cp 在不同集群大小下的端到端延迟。</li><li>结果显示，Cp 的延迟随集群大小线性增长，但总体延迟较低，表明 FlowStalker 的数据收集机制非常高效。</li></ul></li></ul><p align="center"><img width="70%" src="'+s+'"></p><h2 id="_4-相关工作" tabindex="-1">4 相关工作 <a class="header-anchor" href="#_4-相关工作" aria-label="Permalink to &quot;4 相关工作&quot;">​</a></h2><ul><li><strong>传统监控方法:</strong> 如 sFlow 和 NetFlow，通过采样或聚合流量信息来减少开销，但可能牺牲了数据的准确性。</li><li><strong>新兴监控方法:</strong> 如 In-band Network Telemetry (INT)，通过在数据包头部附加元数据来监控网络状态，但需要控制平面的持续参与。</li><li><strong>类似工作:</strong> 如 Marple 和 StreaMon，也利用数据平面的可编程性进行监控，但 FlowStalker 更注重与控制平面的分离和效率。</li></ul><h2 id="_5-结论与未来工作" tabindex="-1">5 结论与未来工作 <a class="header-anchor" href="#_5-结论与未来工作" aria-label="Permalink to &quot;5 结论与未来工作&quot;">​</a></h2><h3 id="_5-1-结论" tabindex="-1">5.1 结论 <a class="header-anchor" href="#_5-1-结论" aria-label="Permalink to &quot;5.1 结论&quot;">​</a></h3><ul><li>FlowStalker 提供了一种高效、准确的网络流量监控方法，通过 P4 实现了数据平面的可编程性。</li><li>通过两阶段监控机制和 Cp 数据收集机制，FlowStalker 减少了对控制平面的依赖，降低了通信开销，同时保持了较高的监控精度。</li></ul><h3 id="_5-2-未来工作" tabindex="-1">5.2 未来工作 <a class="header-anchor" href="#_5-2-未来工作" aria-label="Permalink to &quot;5.2 未来工作&quot;">​</a></h3><ul><li>开发 FlowStalker 的控制平面对应模块，以实现数据平面和控制平面之间的协同工作。</li><li>允许控制平面运行更复杂的处理算法，并通过 Cp 定期交换信息。</li></ul>',38)]))}const f=t(h,[["render",d]]);export{_ as __pageData,f as default};
