import{_ as o,o as e,c as t,R as i}from"./chunks/framework._QHn8SP1.js";const l="/assets/tcp.Fp7AL0Qq.webp",a="/assets/tcp3.bfds6BzQ.png",c="/assets/tcp4.dOH4z5DR.png",u=JSON.parse('{"title":"网络协议","description":"","frontmatter":{},"headers":[],"relativePath":"notes/protocol.md","filePath":"notes/protocol.md"}'),s={name:"notes/protocol.md"},p=i('<h1 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-label="Permalink to &quot;网络协议&quot;">​</a></h1><p>数据传输过程：</p><ol><li>应用层对请求数据包做格式定义</li><li>传输层加端口号，确认应用程序</li><li>网络层加双方IP，确认网络位置</li><li>链路层加双方MAC地址，确认物理位置。将数据分组，形成数据帧并转发给目标主机。</li></ol><p>TCP：面向连接的可靠协议<br> UDP：面向无连接的协议</p><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><p><img src="'+l+'" alt="TCP报文"></p><ul><li><code>seq</code>：数据序号，存储本报文段所发送数据的第一个字节的序号</li><li><code>ack</code>：确认序号，期望收到对方的下一个报文段的数据的第一个字节的序号</li><li><code>ACK</code>：确认标志位，当 <code>ACK=1</code> 时，确认序号才有效</li><li><code>SYN</code>：同步标志位，表示这个报文是一个连接请求还是一个连接接受的请求</li><li><code>FIN</code>：结束标志位，当 <code>FIN=1</code> 时，表示此报文段的发送端的数据已经发送完成，并且要求释放连接</li></ul><p>三次握手：</p><p><img src="'+a+'" alt="Alt text"></p><p>四次挥手： <img src="'+c+'" alt="Alt text"></p><p>问题：为什么TCP客户端最后发送释放确认报文后还要再等待2MSL？<br> 因为客户端无法确认TCP服务器是否收到了报文，如果TCP服务器没有收到就会重发连接释放的报文，则客户进程会再次发送确认报文。如果两倍MSL时间内都没有重新收到TCP服务器的连接释放报文，那么客户端推断确认报文已经被服务端成功接受，从而关闭连接。</p><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><p>HTTP请求响应模型：</p><ol><li>建立TCP连接</li><li>客户端向服务器发送请求命令</li><li>客户端发送请求头信息</li><li>客户端发送空行，表示结束请求头信息的发送</li><li>服务器应答</li><li>服务器返回响应头信息</li><li>服务端向客户端发送数据</li><li>服务器关闭TCP连接</li></ol><p>如果客户端频繁发送HTTP请求，会导致TCP连接频繁的建立和关闭。因此在需要频繁发送HTTP请求时，请求头可以带上 <code>Connection: keep-alive</code> 保持持久连接。HTTP1.1版本之后默认都是持久连接。</p><p>HTTP的相关特性：</p><ol><li>HTTP是无状态的的协议。可以引入 Cookie 和 Session 技术管理状态。</li><li>HTTP使用 Cookie 来进行客户端的状态管理。服务器响应时通过添加头信息 <code>Set-Cookie: xxx</code> 通知客户端保存该 Cookie 信息，下次客户端发送请求时就会带上 Cookie 信息。</li><li>管线化访问。一个请求没有响应也能发送下一个请求，可以并行发送多个请求。</li></ol>',17),r=[p];function d(n,T,_,P,h,C){return e(),t("div",null,r)}const f=o(s,[["render",d]]);export{u as __pageData,f as default};
